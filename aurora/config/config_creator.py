"""
Helper class to make config files.

Note: the config is still evolving and this class and its methods are expected to
change.


"""
from pathlib import Path

from aurora.config import Processing, Station, Run, BANDS_DEFAULT_FILE


class ConfigCreator:
    def __init__(self, **kwargs):
        default_config_path = Path("config")
        self.config_path = kwargs.get("config_path", default_config_path)
        self._band_specification_style = None

    def processing_id(self, kernel_dataset):
        """
        In the past, we used f"{local}-{remote}" or  f"{local}-{run_id}"
        Neither of these is sufficiently unique.  In fact, they only describe the
        dataset, and not the processing config.  It is difficult to see how to make a
        comprehensive, unique id without it being very long or involving hash
        functions.

        For now, will try to use {local}-{local_runs}-{remote}-{remote_runs},
        which at least describes the dataset, then a string can be generated by the
        config and appended if needed.


        Parameters
        ----------
        kernel_dataset

        Returns
        -------

        """
        id = f"{kernel_dataset.local_station_id}-{kernel_dataset.remote_station_id}"
        return id

    @property
    def band_specification_style(self):
        return self._band_specification_style

    def determine_band_specification_style(self):
        """
        ? Should emtf_band_file path be stored in config?
        It would support reproducability.

        Parameters
        ----------
        emtf_band_file
        band_edges

        """

        if (self._emtf_band_file is None) & (self._band_edges is None):
            print("Bands not defined; setting to EMTF BANDS_DEFAULT_FILE")
            self._emtf_band_file = BANDS_DEFAULT_FILE
            self._band_specification_style = "EMTF"
        elif (self._emtf_band_file is not None) & (self._band_edges is not None):
            print("Bands defined twice, and possibly inconsistantly")
            raise Exception
        elif self._band_edges is not None:
            self._band_specification_style = "band_edges"
        elif self._emtf_band_file is not None:
            self._band_specification_style = "EMTF"
        else:
            print("method of band specifciation is unrecognized")
            raise NotImplementedError

    def create_from_kernel_dataset(
        self,
        kernel_dataset,
        input_channels=["hx", "hy"],
        output_channels=["hz", "ex", "ey"],
        estimator=None,
        **kwargs,
    ):
        """
        Hmmm, why not make this a method of kernel_dataset??

        Parameters
        ----------
        kernel_dataset
        emtf_band_file: while the default here is None, it will get assigned the
        value BANDS_DEFAULT_FILE in the set_frequecy_bands method if band edges is
        also None.
        input_channels
        output_channels
        estimator
        band_edges
        kwargs

        Returns
        -------

        """

        processing_id = self.processing_id(kernel_dataset)
        processing_obj = Processing(id=processing_id)  # , **kwargs)

        # pack station and run info into processing object
        processing_obj.stations.from_dataset_dataframe(kernel_dataset.df)

        # Unpack kwargs
        self._emtf_band_file = kwargs.get("emtf_band_file", None)
        self._band_edges = kwargs.get("band_edges", None)
        decimation_factors = kwargs.get("decimation_factors", None)
        num_samples_window = kwargs.get("num_samples_window", None)

        # Determine if band_setup or edges dict is to be used for bands
        self.determine_band_specification_style()

        # Set Frequency Bands
        if self.band_specification_style == "EMTF":
            processing_obj.read_emtf_bands(self._emtf_band_file)
            processing_obj.assign_decimation_level_data_emtf(kernel_dataset.sample_rate)
        elif self.band_specification_style == "band_edges":
            processing_obj.assign_bands(
                self._band_edges,
                kernel_dataset.sample_rate,
                decimation_factors,
                num_samples_window,
            )

        # if num_samples_window is not None:
        #     if isinstance(num_samples_window, int):
        #
        #         print("")
        #         #num_samples_window = dict(zip(processing_obj.num_decimation_levels()
        #         #                              * [num_samples_window]

        for key, decimation_obj in processing_obj.decimations_dict.items():
            decimation_obj.input_channels = input_channels
            decimation_obj.output_channels = output_channels
            if num_samples_window is not None:
                decimation_obj.window.num_samples = num_samples_window[key]
            # set estimator if provided as kwarg
            if estimator:
                try:
                    decimation_obj.estimator.engine = estimator["engine"]
                except KeyError:
                    pass
        return processing_obj

    def to_json(self, processing_obj, path=None, nested=True, required=False):
        """
        Write a processing object to path

        :param path: DESCRIPTION
        :type path: TYPE
        :param processing_obj: DESCRIPTION
        :type processing_obj: TYPE
        :return: DESCRIPTION
        :rtype: TYPE

        """
        if path is None:
            json_fn = processing_obj.json_fn()  # config_id + "_run_config.json"
            self.config_path.mkdir(exist_ok=True)
            path = self.config_path.joinpath(json_fn)
        with open(path, "w") as fid:
            json_obj = processing_obj.to_json(nested=nested, required=required)
            fid.write(json_obj)
